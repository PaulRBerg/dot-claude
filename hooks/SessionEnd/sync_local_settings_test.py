#!/usr/bin/env python3
"""Unit tests for sync_local_settings.py hook."""

import json
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

import sync_local_settings


class TestIsAutoGeneratedSkill:
    """Test is_auto_generated_skill() function."""

    def test_detects_local_skill(self):
        """Test detecting local skill permission."""
        assert sync_local_settings.is_auto_generated_skill("Skill(typescript)") is True
        assert sync_local_settings.is_auto_generated_skill("Skill(gh-cli)") is True

    def test_rejects_plugin_skill(self):
        """Test rejecting plugin skill (has colon)."""
        assert sync_local_settings.is_auto_generated_skill("Skill(plugin:name)") is False
        assert sync_local_settings.is_auto_generated_skill("Skill(sablier:effect-ts)") is False

    def test_rejects_non_skill(self):
        """Test rejecting non-skill permissions."""
        assert sync_local_settings.is_auto_generated_skill("Bash(git:*)") is False
        assert sync_local_settings.is_auto_generated_skill("Other(name)") is False
        assert sync_local_settings.is_auto_generated_skill("SlashCommand(/commit:*)") is False


class TestIsAutoGeneratedCommand:
    """Test is_auto_generated_command() function."""

    def test_detects_local_command(self):
        """Test detecting local command permission."""
        assert sync_local_settings.is_auto_generated_command("SlashCommand(/commit:*)") is True
        assert sync_local_settings.is_auto_generated_command("SlashCommand(/create-pr:*)") is True

    def test_rejects_plugin_command(self):
        """Test rejecting plugin command (has colon in path)."""
        assert (
            sync_local_settings.is_auto_generated_command("SlashCommand(/plugin:name:*)") is False
        )
        assert (
            sync_local_settings.is_auto_generated_command("SlashCommand(/sablier:spec:*)") is False
        )

    def test_rejects_non_command(self):
        """Test rejecting non-command permissions."""
        assert sync_local_settings.is_auto_generated_command("Bash(git:*)") is False
        assert sync_local_settings.is_auto_generated_command("Skill(name)") is False


class TestIsAutoGenerated:
    """Test is_auto_generated() function."""

    def test_detects_skills(self):
        """Test detecting auto-generated skills."""
        assert sync_local_settings.is_auto_generated("Skill(typescript)") is True

    def test_detects_commands(self):
        """Test detecting auto-generated commands."""
        assert sync_local_settings.is_auto_generated("SlashCommand(/commit:*)") is True

    def test_rejects_user_permissions(self):
        """Test rejecting user-defined permissions."""
        assert sync_local_settings.is_auto_generated("Bash(git:*)") is False
        assert sync_local_settings.is_auto_generated("Read(/tmp/**)") is False
        assert sync_local_settings.is_auto_generated("Skill(plugin:name)") is False


class TestDiscoverSkills:
    """Test discover_skills() function."""

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR", Path("/fake/.claude"))
    @patch("pathlib.Path.glob")
    @patch("pathlib.Path.exists")
    def test_finds_skills_with_skill_md(self, mock_exists, mock_glob):
        """Test discovering skills from SKILL.md files."""
        mock_exists.return_value = True
        mock_skill1 = MagicMock()
        mock_skill1.parent.name = "typescript"
        mock_skill2 = MagicMock()
        mock_skill2.parent.name = "gh-cli"
        mock_glob.return_value = [mock_skill1, mock_skill2]

        result = sync_local_settings.discover_skills()

        assert "Skill(typescript)" in result
        assert "Skill(gh-cli)" in result

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR", Path("/fake/.claude"))
    @patch("pathlib.Path.exists")
    def test_returns_empty_for_missing_directory(self, mock_exists):
        """Test returning empty list when skills directory doesn't exist."""
        mock_exists.return_value = False
        result = sync_local_settings.discover_skills()
        assert result == []


class TestDiscoverCommands:
    """Test discover_commands() function."""

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR", Path("/fake/.claude"))
    @patch("pathlib.Path.glob")
    @patch("pathlib.Path.exists")
    def test_finds_commands_with_md_files(self, mock_exists, mock_glob):
        """Test discovering commands from .md files."""
        mock_exists.return_value = True
        mock_cmd1 = MagicMock()
        mock_cmd1.stem = "commit"
        mock_cmd2 = MagicMock()
        mock_cmd2.stem = "create-pr"
        mock_glob.return_value = [mock_cmd1, mock_cmd2]

        result = sync_local_settings.discover_commands()

        assert "SlashCommand(/commit:*)" in result
        assert "SlashCommand(/create-pr:*)" in result

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR", Path("/fake/.claude"))
    @patch("pathlib.Path.exists")
    def test_returns_empty_for_missing_directory(self, mock_exists):
        """Test returning empty list when commands directory doesn't exist."""
        mock_exists.return_value = False
        result = sync_local_settings.discover_commands()
        assert result == []


class TestReadExistingSettings:
    """Test read_existing_settings() function."""

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_reads_valid_json(self, mock_path):
        """Test reading valid JSON settings."""
        mock_path.exists.return_value = True
        mock_path.read_text.return_value = '{"key": "value"}'
        result = sync_local_settings.read_existing_settings()
        assert result == {"key": "value"}

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_returns_empty_for_missing_file(self, mock_path):
        """Test returning empty dict when file doesn't exist."""
        mock_path.exists.return_value = False
        result = sync_local_settings.read_existing_settings()
        assert result == {}

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_returns_empty_for_invalid_json(self, mock_path):
        """Test returning empty dict on JSON decode error."""
        mock_path.exists.return_value = True
        mock_path.read_text.return_value = "{ invalid json"
        result = sync_local_settings.read_existing_settings()
        assert result == {}


class TestExtractUserPermissions:
    """Test extract_user_permissions() function."""

    def test_extracts_user_permissions(self):
        """Test extracting only user-defined permissions."""
        settings = {
            "permissions": {
                "allow": [
                    "Bash(git:*)",
                    "Skill(typescript)",  # auto-generated
                    "Read(/tmp/**)",
                    "SlashCommand(/commit:*)",  # auto-generated
                ]
            }
        }
        result = sync_local_settings.extract_user_permissions(settings)
        assert "Bash(git:*)" in result
        assert "Read(/tmp/**)" in result
        assert "Skill(typescript)" not in result
        assert "SlashCommand(/commit:*)" not in result

    def test_handles_empty_config(self):
        """Test handling empty configuration."""
        result = sync_local_settings.extract_user_permissions({})
        assert result == []

    def test_handles_missing_permissions(self):
        """Test handling config without permissions key."""
        result = sync_local_settings.extract_user_permissions({"other": "key"})
        assert result == []


class TestBuildSettings:
    """Test build_settings() function."""

    def test_builds_with_schema(self):
        """Test output includes $schema."""
        result = sync_local_settings.build_settings({}, [], [], [])
        assert "$schema" in result
        assert result["$schema"] == "https://json.schemastore.org/claude-code-settings.json"

    def test_preserves_existing_fields(self):
        """Test preserving non-permission fields from existing settings."""
        existing = {"customField": "value", "another": 123}
        result = sync_local_settings.build_settings(existing, [], [], [])
        assert result["customField"] == "value"
        assert result["another"] == 123

    def test_merges_all_permissions(self):
        """Test merging user permissions, skills, and commands."""
        user_perms = ["Bash(git:*)"]
        skills = ["Skill(typescript)"]
        commands = ["SlashCommand(/commit:*)"]
        result = sync_local_settings.build_settings({}, user_perms, skills, commands)
        allow = result["permissions"]["allow"]
        assert "Bash(git:*)" in allow
        assert "Skill(typescript)" in allow
        assert "SlashCommand(/commit:*)" in allow

    def test_sorts_permissions(self):
        """Test permissions are sorted alphabetically."""
        user_perms = ["Bash(z:*)", "Bash(a:*)"]
        result = sync_local_settings.build_settings({}, user_perms, [], [])
        allow = result["permissions"]["allow"]
        assert allow == sorted(allow)

    def test_preserves_deny_permissions(self):
        """Test preserving deny array from existing settings."""
        existing = {"permissions": {"deny": ["Bash(rm:*)"]}}
        result = sync_local_settings.build_settings(existing, [], [], [])
        assert result["permissions"]["deny"] == ["Bash(rm:*)"]


class TestWriteSettings:
    """Test write_settings() function."""

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_writes_json_with_newline(self, mock_path):
        """Test writing JSON with trailing newline."""
        mock_path.write_text = MagicMock()
        settings = {"key": "value"}
        result = sync_local_settings.write_settings(settings)
        assert result is True
        call_args = mock_path.write_text.call_args[0][0]
        assert call_args.endswith("\n")
        assert json.loads(call_args.rstrip()) == {"key": "value"}

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_returns_false_on_oserror(self, mock_path):
        """Test returning False on OSError."""
        mock_path.write_text.side_effect = OSError("Permission denied")
        result = sync_local_settings.write_settings({})
        assert result is False


class TestMain:
    """Test main() entry point."""

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_exits_early_when_no_claude_dir(self, mock_dir):
        """Test exiting early when .claude directory doesn't exist."""
        mock_dir.exists.return_value = False

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0

    @patch("sync_local_settings.write_settings")
    @patch("sync_local_settings.read_existing_settings")
    @patch("sync_local_settings.discover_commands")
    @patch("sync_local_settings.discover_skills")
    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_exits_early_when_no_file_and_no_discoveries(
        self,
        mock_dir,
        mock_settings_path,
        mock_skills,
        mock_commands,
        mock_read,
        mock_write,
    ):
        """Test exiting early when no settings file and nothing discovered."""
        mock_dir.exists.return_value = True
        mock_settings_path.exists.return_value = False
        mock_skills.return_value = []
        mock_commands.return_value = []
        mock_read.return_value = {}

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0
        mock_write.assert_not_called()

    @patch("sync_local_settings.write_settings")
    @patch("sync_local_settings.build_settings")
    @patch("sync_local_settings.extract_user_permissions")
    @patch("sync_local_settings.read_existing_settings")
    @patch("sync_local_settings.discover_commands")
    @patch("sync_local_settings.discover_skills")
    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_writes_settings_when_file_exists(
        self,
        mock_dir,
        mock_settings_path,
        mock_skills,
        mock_commands,
        mock_read,
        mock_extract,
        mock_build,
        mock_write,
    ):
        """Test writing settings when settings.json already exists."""
        mock_dir.exists.return_value = True
        mock_settings_path.exists.return_value = True
        mock_skills.return_value = []
        mock_commands.return_value = []
        mock_read.return_value = {"existing": "value"}
        mock_extract.return_value = []
        mock_build.return_value = {"built": "settings"}
        mock_write.return_value = True

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0
        mock_write.assert_called_once_with({"built": "settings"})

    @patch("sync_local_settings.write_settings")
    @patch("sync_local_settings.build_settings")
    @patch("sync_local_settings.extract_user_permissions")
    @patch("sync_local_settings.read_existing_settings")
    @patch("sync_local_settings.discover_commands")
    @patch("sync_local_settings.discover_skills")
    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_writes_settings_when_discoveries_found(
        self,
        mock_dir,
        mock_settings_path,
        mock_skills,
        mock_commands,
        mock_read,
        mock_extract,
        mock_build,
        mock_write,
    ):
        """Test writing settings when skills or commands are discovered."""
        mock_dir.exists.return_value = True
        mock_settings_path.exists.return_value = False  # No file
        mock_skills.return_value = ["Skill(typescript)"]  # But has discoveries
        mock_commands.return_value = []
        mock_read.return_value = {}
        mock_extract.return_value = []
        mock_build.return_value = {"built": "settings"}
        mock_write.return_value = True

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0
        mock_write.assert_called_once()

    @patch("sync_local_settings.write_settings")
    @patch("sync_local_settings.build_settings")
    @patch("sync_local_settings.extract_user_permissions")
    @patch("sync_local_settings.read_existing_settings")
    @patch("sync_local_settings.discover_commands")
    @patch("sync_local_settings.discover_skills")
    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_always_exits_zero(
        self,
        mock_dir,
        mock_settings_path,
        mock_skills,
        mock_commands,
        mock_read,
        mock_extract,
        mock_build,
        mock_write,
    ):
        """Test graceful exit even when write fails."""
        mock_dir.exists.return_value = True
        mock_settings_path.exists.return_value = True
        mock_skills.return_value = []
        mock_commands.return_value = []
        mock_read.return_value = {}
        mock_extract.return_value = []
        mock_build.return_value = {}
        mock_write.return_value = False  # Write fails

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0
