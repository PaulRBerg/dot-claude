#!/usr/bin/env python3
"""Unit tests for sync_local_settings.py hook."""

import json
import subprocess
from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

import sync_local_settings


class TestIsAutoGenerated:
    """Test is_auto_generated() function."""

    def test_detects_local_skill(self):
        """Test detecting local skill permission."""
        assert sync_local_settings.is_auto_generated("Skill(typescript)") is True
        assert sync_local_settings.is_auto_generated("Skill(gh-cli)") is True
        assert sync_local_settings.is_auto_generated("Skill(commit)") is True

    def test_rejects_plugin_skill(self):
        """Test rejecting plugin skill (has colon)."""
        assert sync_local_settings.is_auto_generated("Skill(plugin:name)") is False
        assert sync_local_settings.is_auto_generated("Skill(sablier:effect-ts)") is False

    def test_rejects_non_skill(self):
        """Test rejecting non-skill permissions."""
        assert sync_local_settings.is_auto_generated("Bash(git:*)") is False
        assert sync_local_settings.is_auto_generated("Other(name)") is False
        assert sync_local_settings.is_auto_generated("Read(/tmp/**)") is False


class TestDiscoverSkills:
    """Test discover_skills() function."""

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR", Path("/fake/.claude"))
    @patch("pathlib.Path.glob")
    @patch("pathlib.Path.exists")
    def test_finds_skills_with_skill_md(self, mock_exists, mock_glob):
        """Test discovering skills from SKILL.md files."""
        mock_exists.return_value = True
        mock_skill1 = MagicMock()
        mock_skill1.parent.name = "typescript"
        mock_skill2 = MagicMock()
        mock_skill2.parent.name = "gh-cli"
        mock_glob.return_value = [mock_skill1, mock_skill2]

        result = sync_local_settings.discover_skills()

        assert "Skill(typescript)" in result
        assert "Skill(gh-cli)" in result

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR", Path("/fake/.claude"))
    @patch("pathlib.Path.exists")
    def test_returns_empty_for_missing_directory(self, mock_exists):
        """Test returning empty list when skills directory doesn't exist."""
        mock_exists.return_value = False
        result = sync_local_settings.discover_skills()
        assert result == []


class TestDiscoverCommands:
    """Test discover_commands() function."""

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR", Path("/fake/.claude"))
    @patch("pathlib.Path.glob")
    @patch("pathlib.Path.exists")
    def test_finds_commands_with_md_files(self, mock_exists, mock_glob):
        """Test discovering commands from .md files."""
        mock_exists.return_value = True
        mock_cmd1 = MagicMock()
        mock_cmd1.stem = "commit"
        mock_cmd2 = MagicMock()
        mock_cmd2.stem = "create-pr"
        mock_glob.return_value = [mock_cmd1, mock_cmd2]

        result = sync_local_settings.discover_commands()

        assert "Skill(commit)" in result
        assert "Skill(create-pr)" in result

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR", Path("/fake/.claude"))
    @patch("pathlib.Path.exists")
    def test_returns_empty_for_missing_directory(self, mock_exists):
        """Test returning empty list when commands directory doesn't exist."""
        mock_exists.return_value = False
        result = sync_local_settings.discover_commands()
        assert result == []


class TestReadExistingSettings:
    """Test read_existing_settings() function."""

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_reads_valid_json(self, mock_path):
        """Test reading valid JSON settings."""
        mock_path.exists.return_value = True
        mock_path.read_text.return_value = '{"key": "value"}'
        result = sync_local_settings.read_existing_settings()
        assert result == {"key": "value"}

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_returns_empty_for_missing_file(self, mock_path):
        """Test returning empty dict when file doesn't exist."""
        mock_path.exists.return_value = False
        result = sync_local_settings.read_existing_settings()
        assert result == {}

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_returns_empty_for_invalid_json(self, mock_path):
        """Test returning empty dict on JSON decode error."""
        mock_path.exists.return_value = True
        mock_path.read_text.return_value = "{ invalid json"
        result = sync_local_settings.read_existing_settings()
        assert result == {}


class TestExtractUserPermissions:
    """Test extract_user_permissions() function."""

    def test_extracts_user_permissions(self):
        """Test extracting only user-defined permissions."""
        settings = {
            "permissions": {
                "allow": [
                    "Bash(git:*)",
                    "Skill(typescript)",  # auto-generated (no colon)
                    "Read(/tmp/**)",
                    "Skill(plugin:name)",  # user-defined (has colon)
                ]
            }
        }
        result = sync_local_settings.extract_user_permissions(settings)
        assert "Bash(git:*)" in result
        assert "Read(/tmp/**)" in result
        assert "Skill(plugin:name)" in result
        assert "Skill(typescript)" not in result

    def test_handles_empty_config(self):
        """Test handling empty configuration."""
        result = sync_local_settings.extract_user_permissions({})
        assert result == []

    def test_handles_missing_permissions(self):
        """Test handling config without permissions key."""
        result = sync_local_settings.extract_user_permissions({"other": "key"})
        assert result == []


class TestBuildSettings:
    """Test build_settings() function."""

    def test_builds_with_schema(self):
        """Test output includes $schema."""
        result = sync_local_settings.build_settings({}, [], [], [])
        assert "$schema" in result
        assert result["$schema"] == "https://json.schemastore.org/claude-code-settings.json"

    def test_preserves_existing_fields(self):
        """Test preserving non-permission fields from existing settings."""
        existing = {"customField": "value", "another": 123}
        result = sync_local_settings.build_settings(existing, [], [], [])
        assert result["customField"] == "value"
        assert result["another"] == 123

    def test_merges_all_permissions(self):
        """Test merging user permissions, skills, and commands."""
        user_perms = ["Bash(git:*)"]
        skills = ["Skill(typescript)"]
        commands = ["Skill(commit)"]
        result = sync_local_settings.build_settings({}, user_perms, skills, commands)
        allow = result["permissions"]["allow"]
        assert "Bash(git:*)" in allow
        assert "Skill(typescript)" in allow
        assert "Skill(commit)" in allow

    def test_sorts_permissions(self):
        """Test permissions are sorted alphabetically."""
        user_perms = ["Bash(z:*)", "Bash(a:*)"]
        result = sync_local_settings.build_settings({}, user_perms, [], [])
        allow = result["permissions"]["allow"]
        assert allow == sorted(allow)

    def test_preserves_deny_permissions(self):
        """Test preserving deny array from existing settings."""
        existing = {"permissions": {"deny": ["Bash(rm:*)"]}}
        result = sync_local_settings.build_settings(existing, [], [], [])
        assert result["permissions"]["deny"] == ["Bash(rm:*)"]


class TestWriteSettings:
    """Test write_settings() function."""

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_writes_json_with_newline(self, mock_path):
        """Test writing JSON with trailing newline."""
        mock_path.write_text = MagicMock()
        settings = {"key": "value"}
        result = sync_local_settings.write_settings(settings)
        assert result is True
        call_args = mock_path.write_text.call_args[0][0]
        assert call_args.endswith("\n")
        assert json.loads(call_args.rstrip()) == {"key": "value"}

    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    def test_returns_false_on_oserror(self, mock_path):
        """Test returning False on OSError."""
        mock_path.write_text.side_effect = OSError("Permission denied")
        result = sync_local_settings.write_settings({})
        assert result is False


class TestFormatWithBiome:
    """Test format_with_biome() function."""

    @patch("subprocess.run")
    def test_formats_from_project_root(self, mock_run):
        """Test formatting with project root as working directory."""
        mock_run.return_value = MagicMock(returncode=0)

        path = Path("/project/.claude/settings.json")
        result = sync_local_settings.format_with_biome(path)

        assert result is True
        mock_run.assert_called_once_with(
            ["biome", "format", "--write", "/project/.claude/settings.json"],
            capture_output=True,
            text=True,
            timeout=30,
            cwd=Path("/project"),
        )

    @patch("subprocess.run")
    def test_returns_false_on_nonzero_exit(self, mock_run):
        """Test returning False when biome exits with failure."""
        mock_run.return_value = MagicMock(returncode=1)

        result = sync_local_settings.format_with_biome(Path("/project/.claude/settings.json"))

        assert result is False

    @patch("subprocess.run")
    def test_returns_false_on_timeout(self, mock_run):
        """Test returning False on timeout."""
        mock_run.side_effect = subprocess.TimeoutExpired("biome", 30)

        result = sync_local_settings.format_with_biome(Path("/project/.claude/settings.json"))

        assert result is False


class TestMain:
    """Test main() entry point."""

    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_exits_early_when_no_claude_dir(self, mock_dir):
        """Test exiting early when .claude directory doesn't exist."""
        mock_dir.exists.return_value = False

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0

    @patch("sync_local_settings.write_settings")
    @patch("sync_local_settings.read_existing_settings")
    @patch("sync_local_settings.discover_commands")
    @patch("sync_local_settings.discover_skills")
    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_exits_early_when_no_file_and_no_discoveries(
        self,
        mock_dir,
        mock_settings_path,
        mock_skills,
        mock_commands,
        mock_read,
        mock_write,
    ):
        """Test exiting early when no settings file and nothing discovered."""
        mock_dir.exists.return_value = True
        mock_settings_path.exists.return_value = False
        mock_skills.return_value = []
        mock_commands.return_value = []
        mock_read.return_value = {}

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0
        mock_write.assert_not_called()

    @patch("sync_local_settings.write_settings")
    @patch("sync_local_settings.build_settings")
    @patch("sync_local_settings.extract_user_permissions")
    @patch("sync_local_settings.read_existing_settings")
    @patch("sync_local_settings.discover_commands")
    @patch("sync_local_settings.discover_skills")
    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_writes_settings_when_file_exists(
        self,
        mock_dir,
        mock_settings_path,
        mock_skills,
        mock_commands,
        mock_read,
        mock_extract,
        mock_build,
        mock_write,
    ):
        """Test writing settings when settings.json already exists."""
        mock_dir.exists.return_value = True
        mock_settings_path.exists.return_value = True
        mock_skills.return_value = []
        mock_commands.return_value = []
        mock_read.return_value = {"existing": "value"}
        mock_extract.return_value = []
        mock_build.return_value = {"built": "settings"}
        mock_write.return_value = True

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0
        mock_write.assert_called_once_with({"built": "settings"})

    @patch("sync_local_settings.write_settings")
    @patch("sync_local_settings.build_settings")
    @patch("sync_local_settings.extract_user_permissions")
    @patch("sync_local_settings.read_existing_settings")
    @patch("sync_local_settings.discover_commands")
    @patch("sync_local_settings.discover_skills")
    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_writes_settings_when_discoveries_found(
        self,
        mock_dir,
        mock_settings_path,
        mock_skills,
        mock_commands,
        mock_read,
        mock_extract,
        mock_build,
        mock_write,
    ):
        """Test writing settings when skills or commands are discovered."""
        mock_dir.exists.return_value = True
        mock_settings_path.exists.return_value = False  # No file
        mock_skills.return_value = ["Skill(typescript)"]  # But has discoveries
        mock_commands.return_value = []
        mock_read.return_value = {}
        mock_extract.return_value = []
        mock_build.return_value = {"built": "settings"}
        mock_write.return_value = True

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0
        mock_write.assert_called_once()

    @patch("sync_local_settings.write_settings")
    @patch("sync_local_settings.build_settings")
    @patch("sync_local_settings.extract_user_permissions")
    @patch("sync_local_settings.read_existing_settings")
    @patch("sync_local_settings.discover_commands")
    @patch("sync_local_settings.discover_skills")
    @patch.object(sync_local_settings, "LOCAL_SETTINGS")
    @patch.object(sync_local_settings, "LOCAL_CLAUDE_DIR")
    def test_always_exits_zero(
        self,
        mock_dir,
        mock_settings_path,
        mock_skills,
        mock_commands,
        mock_read,
        mock_extract,
        mock_build,
        mock_write,
    ):
        """Test graceful exit even when write fails."""
        mock_dir.exists.return_value = True
        mock_settings_path.exists.return_value = True
        mock_skills.return_value = []
        mock_commands.return_value = []
        mock_read.return_value = {}
        mock_extract.return_value = []
        mock_build.return_value = {}
        mock_write.return_value = False  # Write fails

        with pytest.raises(SystemExit) as exc_info:
            sync_local_settings.main()

        assert exc_info.value.code == 0
