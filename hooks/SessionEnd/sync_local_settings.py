#!/usr/bin/env python3
"""Sync local project skills and commands to ./.claude/settings.json.

Discovers skills from ./.claude/skills/*/SKILL.md and commands from
./.claude/commands/*.md, then merges into ./.claude/settings.json
preserving user-defined permissions.

Runs at SessionEnd. Exits early if no .claude/ directory in CWD.
"""

import json
import re
import subprocess
import sys
from pathlib import Path

# === CONSTANTS ===

LOCAL_CLAUDE_DIR = Path.cwd() / ".claude"
LOCAL_SETTINGS = LOCAL_CLAUDE_DIR / "settings.json"
SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json"


# === PERMISSION DETECTION ===


def is_auto_generated_skill(perm: str) -> bool:
    """Check if permission is an auto-generated local skill.

    Local skills have format Skill(name) without colons.
    Plugin skills have format Skill(plugin:name) with colons.

    Args:
        perm: Permission string to check

    Returns:
        True if this is a local skill permission
    """
    match = re.match(r"^Skill\(([^)]+)\)$", perm)
    return bool(match and ":" not in match.group(1))


def is_auto_generated_command(perm: str) -> bool:
    """Check if permission is an auto-generated local command.

    Local commands: SlashCommand(/name:*)
    Plugin commands: SlashCommand(/plugin:name:*)

    Args:
        perm: Permission string to check

    Returns:
        True if this is a local command permission
    """
    match = re.match(r"^SlashCommand\(/([^:]+):\*\)$", perm)
    return match is not None


def is_auto_generated(perm: str) -> bool:
    """Check if permission was auto-generated by this script.

    Args:
        perm: Permission string to check

    Returns:
        True if this is an auto-generated permission
    """
    return is_auto_generated_skill(perm) or is_auto_generated_command(perm)


# === DISCOVERY ===


def discover_skills() -> list[str]:
    """Find local skills by looking for SKILL.md files.

    Returns:
        List of skill names in Skill(name) format
    """
    skills_dir = LOCAL_CLAUDE_DIR / "skills"
    if not skills_dir.exists():
        return []

    return [f"Skill({skill_md.parent.name})" for skill_md in skills_dir.glob("*/SKILL.md")]


def discover_commands() -> list[str]:
    """Find local commands by looking for .md files.

    Returns:
        List of command names in SlashCommand(/name:*) format
    """
    commands_dir = LOCAL_CLAUDE_DIR / "commands"
    if not commands_dir.exists():
        return []

    return [f"SlashCommand(/{cmd_file.stem}:*)" for cmd_file in commands_dir.glob("*.md")]


def discover_command_groups() -> list[str]:
    """Find command groups by looking for subdirectories with .md files.

    Returns:
        List of group names in SlashCommand(/group:*) format
    """
    commands_dir = LOCAL_CLAUDE_DIR / "commands"
    if not commands_dir.exists():
        return []

    return [
        f"SlashCommand(/{subdir.name}:*)"
        for subdir in commands_dir.iterdir()
        if subdir.is_dir() and not subdir.name.startswith(".") and any(subdir.glob("*.md"))
    ]


# === SETTINGS MANAGEMENT ===


def read_existing_settings() -> dict:
    """Read existing settings.json, returning empty dict on error.

    Returns:
        Parsed settings or empty dict if file missing/invalid
    """
    if not LOCAL_SETTINGS.exists():
        return {}

    try:
        return json.loads(LOCAL_SETTINGS.read_text())
    except json.JSONDecodeError:
        return {}


def extract_user_permissions(settings: dict) -> list[str]:
    """Extract user-defined permissions (non-auto-generated).

    Args:
        settings: Parsed settings.json content

    Returns:
        List of user-defined permission strings
    """
    allow = settings.get("permissions", {}).get("allow", [])
    return [p for p in allow if not is_auto_generated(p)]


def build_settings(
    existing: dict,
    user_permissions: list[str],
    skills: list[str],
    commands: list[str],
) -> dict:
    """Build complete settings.json content.

    Args:
        existing: Existing settings to preserve non-permission fields
        user_permissions: User-defined permissions to preserve
        skills: Discovered skill permissions
        commands: Discovered command permissions

    Returns:
        Complete settings dict ready to write
    """
    all_permissions = sorted(set(user_permissions + skills + commands))

    # Preserve existing settings, update permissions
    result = {
        "$schema": SCHEMA_URL,
        **{k: v for k, v in existing.items() if k not in ("$schema", "permissions")},
        "permissions": {
            **existing.get("permissions", {}),
            "allow": all_permissions,
        },
    }
    return result


def write_settings(settings: dict) -> bool:
    """Write settings to ./.claude/settings.json.

    Args:
        settings: Settings dict to write

    Returns:
        True if write succeeded, False otherwise
    """
    try:
        content = json.dumps(settings, indent=2)
        LOCAL_SETTINGS.write_text(content + "\n")
        return True
    except OSError:
        return False


# === FORMATTING ===


def format_with_biome(path: Path) -> bool:
    """Format file with Biome if biome.jsonc exists in cwd.

    Args:
        path: Path to file to format

    Returns:
        True if formatted successfully or no biome.jsonc, False on error
    """
    biome_config = Path.cwd() / "biome.jsonc"
    if not biome_config.exists():
        return True

    try:
        subprocess.run(
            ["nlx", "biome", "format", "--write", str(path)],
            capture_output=True,
            text=True,
            timeout=30,
        )
        return True
    except (subprocess.TimeoutExpired, subprocess.SubprocessError, OSError):
        return False


# === MAIN ===


def main() -> None:
    """Main hook entry point."""
    # Only run if .claude directory exists in CWD
    if not LOCAL_CLAUDE_DIR.exists():
        sys.exit(0)

    # Discover local skills, commands, and command groups
    skills = discover_skills()
    commands = discover_commands() + discover_command_groups()

    # Read existing settings and preserve user permissions
    existing = read_existing_settings()
    user_permissions = extract_user_permissions(existing)

    # Early exit: nothing to write and no existing file
    if not LOCAL_SETTINGS.exists() and not skills and not commands:
        sys.exit(0)

    # Build and write new settings
    settings = build_settings(existing, user_permissions, skills, commands)
    if write_settings(settings):
        format_with_biome(LOCAL_SETTINGS)

    sys.exit(0)


if __name__ == "__main__":
    main()
