#!/usr/bin/env python3
"""Sync local project skills and commands to ./.claude/settings.json.

Discovers skills from ./.claude/skills/*/SKILL.md and commands from
./.claude/commands/*.md, then merges into ./.claude/settings.json
preserving user-defined permissions.

Runs at SessionEnd. Exits early if no .claude/ directory in CWD.
"""

import json
import re
import sys
from pathlib import Path

# === CONSTANTS ===

LOCAL_CLAUDE_DIR = Path.cwd() / ".claude"
LOCAL_SETTINGS = LOCAL_CLAUDE_DIR / "settings.json"
SCHEMA_URL = "https://json.schemastore.org/claude-code-settings.json"


# === PERMISSION DETECTION ===


def is_auto_generated_skill(perm: str) -> bool:
    """Check if permission is an auto-generated local skill.

    Local skills have format Skill(name) without colons.
    Plugin skills have format Skill(plugin:name) with colons.

    Args:
        perm: Permission string to check

    Returns:
        True if this is a local skill permission
    """
    match = re.match(r"^Skill\(([^)]+)\)$", perm)
    return bool(match and ":" not in match.group(1))


def is_auto_generated_command(perm: str) -> bool:
    """Check if permission is an auto-generated local command.

    Local commands: SlashCommand(/name:*)
    Plugin commands: SlashCommand(/plugin:name:*)

    Args:
        perm: Permission string to check

    Returns:
        True if this is a local command permission
    """
    match = re.match(r"^SlashCommand\(/([^:]+):\*\)$", perm)
    return match is not None


def is_auto_generated(perm: str) -> bool:
    """Check if permission was auto-generated by this script.

    Args:
        perm: Permission string to check

    Returns:
        True if this is an auto-generated permission
    """
    return is_auto_generated_skill(perm) or is_auto_generated_command(perm)


# === DISCOVERY ===


def discover_skills() -> list[str]:
    """Find local skills by looking for SKILL.md files.

    Returns:
        List of skill names in Skill(name) format
    """
    skills_dir = LOCAL_CLAUDE_DIR / "skills"
    if not skills_dir.exists():
        return []

    return [
        f"Skill({skill_md.parent.name})" for skill_md in skills_dir.glob("*/SKILL.md")
    ]


def discover_commands() -> list[str]:
    """Find local commands by looking for .md files.

    Returns:
        List of command names in SlashCommand(/name:*) format
    """
    commands_dir = LOCAL_CLAUDE_DIR / "commands"
    if not commands_dir.exists():
        return []

    return [
        f"SlashCommand(/{cmd_file.stem}:*)" for cmd_file in commands_dir.glob("*.md")
    ]


# === SETTINGS MANAGEMENT ===


def read_existing_settings() -> dict:
    """Read existing settings.json, returning empty dict on error.

    Returns:
        Parsed settings or empty dict if file missing/invalid
    """
    if not LOCAL_SETTINGS.exists():
        return {}

    try:
        return json.loads(LOCAL_SETTINGS.read_text())
    except json.JSONDecodeError:
        return {}


def extract_user_permissions(settings: dict) -> list[str]:
    """Extract user-defined permissions (non-auto-generated).

    Args:
        settings: Parsed settings.json content

    Returns:
        List of user-defined permission strings
    """
    allow = settings.get("permissions", {}).get("allow", [])
    return [p for p in allow if not is_auto_generated(p)]


def build_settings(
    existing: dict,
    user_permissions: list[str],
    skills: list[str],
    commands: list[str],
) -> dict:
    """Build complete settings.json content.

    Args:
        existing: Existing settings to preserve non-permission fields
        user_permissions: User-defined permissions to preserve
        skills: Discovered skill permissions
        commands: Discovered command permissions

    Returns:
        Complete settings dict ready to write
    """
    all_permissions = sorted(set(user_permissions + skills + commands))

    # Preserve existing settings, update permissions
    result = {
        "$schema": SCHEMA_URL,
        **{k: v for k, v in existing.items() if k not in ("$schema", "permissions")},
        "permissions": {
            **existing.get("permissions", {}),
            "allow": all_permissions,
        },
    }
    return result


def write_settings(settings: dict) -> bool:
    """Write settings to ./.claude/settings.json.

    Args:
        settings: Settings dict to write

    Returns:
        True if write succeeded, False otherwise
    """
    try:
        content = json.dumps(settings, indent=2)
        LOCAL_SETTINGS.write_text(content + "\n")
        return True
    except OSError:
        return False


# === MAIN ===


def main() -> None:
    """Main hook entry point."""
    # Only run if .claude directory exists in CWD
    if not LOCAL_CLAUDE_DIR.exists():
        sys.exit(0)

    # Discover local skills and commands
    skills = discover_skills()
    commands = discover_commands()

    # Read existing settings and preserve user permissions
    existing = read_existing_settings()
    user_permissions = extract_user_permissions(existing)

    # Build and write new settings
    settings = build_settings(existing, user_permissions, skills, commands)
    write_settings(settings)

    sys.exit(0)


if __name__ == "__main__":
    main()
